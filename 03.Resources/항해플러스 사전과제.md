# Event 형식의 처리
Charge
1.  charge event 등록
	* event id,
2. point history event 등록
3. transaction ID 생성 (UUID)
4. transaction manager init
	* transaction event store
		* countdownlatch
5.  start transaction => return transaction eventstore

# Dealing with concurrency issue in Kotlin
In Kotlin, handling concurrency issues in a multithreaded environment typically involves leveraging constructs provided by the language itself or external libraries. Here are some strategies and tools commonly used to tackle concurrency issues:

1. **Synchronization**: Kotlin supports traditional synchronization mechanisms such as synchronized blocks and methods, as well as the `@Synchronized` annotation. These can be used to ensure that only one thread executes a critical section of code at a time, preventing race conditions.

```kotlin
val lock = Any()

fun synchronizedMethod() {
    synchronized(lock) {
        // Critical section
    }
}
```

2. **Thread-Safe Data Structures**: Kotlin provides thread-safe implementations of common data structures in the `java.util.concurrent` package, such as `ConcurrentHashMap`, `ConcurrentLinkedQueue`, and `CopyOnWriteArrayList`. These structures are designed to be used in concurrent environments without the need for external synchronization.

```kotlin
val concurrentMap = ConcurrentHashMap<String, Int>()
```

3. **Atomic Operations**: Kotlin provides atomic variables in the `kotlin.concurrent` package, such as `AtomicInteger`, `AtomicBoolean`, etc. These classes ensure that operations on them are atomic and thread-safe without the need for explicit synchronization.

```kotlin
val atomicInteger = AtomicInteger()
atomicInteger.incrementAndGet()
```

4. **Coroutines**: Kotlin Coroutines provide a powerful way to write asynchronous, non-blocking code. With coroutines, you can write asynchronous code in a sequential style, which simplifies concurrency management. Kotlin's `CoroutineScope` and coroutine builders (`launch`, `async`, etc.) help manage concurrent tasks and ensure proper synchronization when needed.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        // Concurrent tasks
    }
    job.join() // Wait for completion
}
```

5. **Actor Model**: The Actor model is a concurrency model where actors (isolated units of computation) communicate by passing messages. Kotlin provides support for this model through libraries like Akka or kotlinx.coroutines with channels. Actors encapsulate their state and can only be accessed through messages, which helps avoid shared mutable state issues.

```kotlin
import kotlinx.coroutines.channels.actor

sealed class Message
data class Increment(val value: Int) : Message()

fun CoroutineScope.counterActor() = actor<Message> {
    var count = 0
    for (msg in channel) {
        when (msg) {
            is Increment -> count += msg.value
        }
    }
}
```

6. **Immutable Data**: Favor immutability whenever possible. Immutable data structures are inherently thread-safe because they cannot be modified once created. Kotlin's standard library provides immutable collections like `List`, `Map`, and `Set`, which are suitable for concurrent environments.

```kotlin
val immutableList = listOf("a", "b", "c")
```

When dealing with concurrency in Kotlin, it's essential to understand the characteristics of each approach and choose the one that best fits the specific requirements of your application. Additionally, thorough testing and proper error handling are crucial to ensure the correctness and reliability of concurrent code.