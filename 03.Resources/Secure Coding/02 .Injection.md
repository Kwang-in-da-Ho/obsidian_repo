## I. 입력데이터 검증
* 신뢰할 수 없는 외부 입력은 철저한 검증작업을 통해 안전한 값만 사용될 수 있도록 통제해야 함
* 신뢰되지 않는 입력 => 신뢰하는 컴포넌트 <규범화, 정규화, 검증> => DB => 출력
* Client 앱에서 먼저 검증, Server 부분에서도 검증이 이뤄져야

## II. SQL Injection
* 외부 입력값을 삽입하여 DB 쿼리문을 생성하는 경우, 쿼리를 변조할 수 있는 입력값을 삽입하여 불법적인 데이터 열람, 삭제, 시스템 명령 수행 등이 발생하는 취약
### 1. 발생 원인
* 쿼리문의 일부로 사용되는 외부 입력값에 대한 검증을 수행하지 않음
### 2. 취약점 진단
1. Form-based SQL Inejction - 입력 form 에 SQL에 사용될 수 있는 특수문자/문자열 입력했을 때 SQL 문 조작이 가능한가?
2. Error-based SQL Injection - URL쿼리, 입력 form에 에러를 발생시키고, 에러메시지에 DB 정보가 노출되는가?
3. UNION SQL Injection - 조회 결과가 출력되는 웹페이서 조작된 쿼리문을 join시켜 원하는 쿼리결과가 출력되는가?
4. Blind SQL Injection - 쿼리 결과를 참/거짓 형태로 요청했을  두 결과가 다르게 표시되는가?
### 3. 제거를 위한 Secure Coding
1. 쿼리를 위한 명령문의 구조를 만든 다음, 외부 입력값을 자료형에 맞게 삽입하여 SQL 조작이 불가능하도록 구현
	* 예시 - JDBC API
		* 동적으로 쿼리 생성 시 string concatenation 보다는 PreparedStatement 클래스에서 제공하는 setString() 등의 메소드를 사용하도록 함
	* 예시2 - Hibernate
		* 마찬가지로 쿼리문을 직접 조작하기보다는 Query 클래스의 setString() 등의 메소드를 사용하여 데이터형을 지정한
	* 예시3 - Mybatis
		* ${} 보다는 #{}를 이용한 바인딩을 사용한 동적 쿼리 생성
2. 입력값 필터링으로 안전한 값만 쿼리문에 사용한다
		![[Pasted image 20231109172340.png]]
		![[Pasted image 20231109172421.png]]

## 4. Command Injection
* 검증을 거치지 않은 입력값이 서버 명령어로 구성되어 실행되는 경우 시스템 권한/정상 동작에 지대한 영향 끼침
* 정말 위험한 공격
* 해결법
	* 사용자의 입력을 받아 shell을 실행하는 기능이 없도록 구현할 것
	* 어쩔 수 없이 있다면 지정된 명령어 중 하나를 골라서 실행하는 구조로 구현할 