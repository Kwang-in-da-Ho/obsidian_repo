# Focus
* TDD, Clean Architecture에 먼저 집중할 것!!
## 다중 인스턴스

## Pessimistic, Optimistic Lock
### Pessimistic Lock
* 트랜잭션 하나가 실패하면 
### Optimistic Lock
* 트랜잭션 하나가 실패하면 이후 트랜잭션도 모두 실패
* 이번 과제의 경우에는 비추

## Clean vs Hexagonal Architecture
* 이석범 코치) Hexagonal 실패한 케이스도 본적 있다.
	* 지나치게 이론적으로 접근했다가 실제에서는 실패한 듯

## TDD
* 어플리케이션의 설계 방식이 변경됨
* 내가 작성하는 코드를 점진적으로 개선하는 과정을 겪어보기
### 통합 테스트
* 단위 테스트로 검증이 되지 않는 테스트들
* 이 로직이 잘 수행되는지 
* "모든 환경이 운영 환경과 똑같은 상태" 에서 하는게 통합테스트가 아니다!
	* 핵심 기능이 돌아가기 위해서 이런저런 요소들이 필요한데, 이들을 가져와서 조합했을 때 내 기능이 잘 돌아가는가? => 이것이 통합테스트.
## Fixture 라이브러리
* Fixture?
	* 동일하거나 유사한 개체 집합에 대해 작동하는 두 개 이상의 테스트가 있는 경우 사용하는 것.
	* 테스트 객체를 

## Architecture
* 꼭 먼저 설계를 다 해야되나?
* 미래에 다 대비할 수 없다.
* 괜히 많은 것을 고려해서 반영했다가 미래에 다 변경되면 
* 현재 상황에 맞게 최대한 빠르게 개발해 나가는 것이 good starting point

## 과제 완성 수준
* 배관적 lock*
# 과제 Architecture
## JPA
테이블의 데이터 수직

Domain : 테이블을 데

# 최원준 코드
* EnrollLessonApplication
* 트랜잭션 layer는 어떤 layer에서 하는가?
	* Application Layer에서도 `@Transactional` 어노테이션이 보임
	* Controller => Application Layer => Service Layer => Repository Layer => Domain Layer => Entity
	* Service 끼리의 호출은 금지
* 좋은 구조!!
	* layer가 적절하게 나누어져 있음
	* layer별로 책임이 분명하게 나누어져 있음
	* clean architecture 관점에서 좋은 구조이다.
	* 추상화/decoupling이 굉장히 잘 되어있다.
* 이 구조의 단점
	* 공수가 많이 듦*
* Repository에 대한 테스트? 어떤 것을 테스트 할 것인가?
### Lessons Learned
* Layer를 나누는 분명한 이유가 있어야 한다
* 각 Layer별로 책임이 분명해야 한다.
* 각 Test Class에서 테스트하려는 것이 명확히 드러나야 한다
	* Controller Test 에서 동시성 테스트? 굳이?
### 테스트 시 DB 구성
* DB 구성은 어떻게 할 것인가?
	* Test Container를 띄워서 테스트
	* (Preferred) H2DB, Redis 등의 In-Memory DB를 이용
		* DBMS 종속성을 최소화하여 테스트
### JPA 관련 성능 저하
* save 시에 불필요한 쿼리 호출됨
* 개발의 편리성을 좀 잃어버린다.

# 이석범 코치님이 생각하는 중요 point
**

